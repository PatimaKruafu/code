// mel_mashBeatDriver.mel

global proc driveMASHFromBeatFile(string $mashNodeAndAttribute, string $filePath, float $peakValue, float $baseValue, int $attackPreFrames, int $decayPostFrames) {
    // ... (rest of the arguments and initial comments remain the same) ...

    // --- Validate Inputs (This section remains the same as the previous corrected version) ---
    string $nodeNamePart = "";
    string $attrNamePart = "";
    string $buffer[];
    int $numTokens = tokenize($mashNodeAndAttribute, ".", $buffer);

    if ($numTokens >= 2) {
        $nodeNamePart = $buffer[0];
        $attrNamePart = $buffer[1];
        if ($numTokens > 2) {
            for ($i=2; $i<$numTokens; $i++) {
                $attrNamePart += "." + $buffer[$i];
            }
            $mashNodeAndAttribute = $nodeNamePart + "." + $attrNamePart;
        }
    } else {
        warning ("MASH Attribute '" + $mashNodeAndAttribute + "' is not in the required 'Node.Attribute' format (e.g., MASH1_Offset1.strength).");
        return;
    }
    if (!objExists($nodeNamePart)) {
        warning ("Node '" + $nodeNamePart + "' (from '" + $mashNodeAndAttribute + "') does not exist.");
        return;
    }
    if (!objExists($mashNodeAndAttribute)) { 
        warning ("Attribute '" + $mashNodeAndAttribute + "' does not exist on node '" + $nodeNamePart + "'.");
        return;
    }
    // --- End Input Validation ---


    int $fileID = fopen($filePath, "r");
    if ($fileID == 0) {
        warning ("Could not open file: " + $filePath);
        return;
    }

    // --- Get FPS for time-to-frame conversion ---
    // ++ Alternative FPS Detection Method ++
    float $fps = 24.0; // Default FPS
    string $timeUnitSetting = `currentUnit -query -time`; // This gets the current time unit string (e.g., "film", "ntsc")

    switch ($timeUnitSetting) {
        case "game":    $fps = 15.0; break;
        case "film":    $fps = 24.0; break;
        case "pal":     $fps = 25.0; break;
        case "ntsc":    $fps = 30.0; break;
        case "show":    
            // For "show", we try to get the value from optionVar, though it might not always be up-to-date
            // if changed programmatically without saving preferences.
            if (`optionVar -exists workingUnitTimeFrameRate`) {
                string $showRate = `optionVar -query workingUnitTimeFrameRate`;
                // The optionVar stores it like "ntsc", "film", "2fps", "1000fps" etc.
                // So we re-evaluate. This is a bit recursive but handles "Nfps" stored in show.
                if (endsWith($showRate, "fps")) {
                    string $fpsStr = substring($showRate, 1, size($showRate)-3);
                    $fps = (float)$fpsStr;
                } else {
                    // If it's a named preset like "ntsc" stored in "show", map it again.
                    switch ($showRate) {
                        case "game":    $fps = 15.0; break;
                        case "film":    $fps = 24.0; break;
                        case "pal":     $fps = 25.0; break;
                        case "ntsc":    $fps = 30.0; break;
                        case "palf":    $fps = 50.0; break;
                        case "ntscf":   $fps = 60.0; break;
                        default:
                            warning("Time unit is 'show' with an unrecognized rate '" + $showRate + "'. Assuming 24 FPS.");
                            $fps = 24.0;
                            break;
                    }
                }
            } else {
                 warning ("Time unit is 'show' and workingUnitTimeFrameRate optionVar not found. Assuming 24 FPS.");
                 $fps = 24.0;
            }
            break;
        case "palf":    $fps = 50.0; break;
        case "ntscf":   $fps = 60.0; break;
        case "millisec": $fps = 1000.0; break; // Milliseconds is effectively 1000 "frames" per second
        // Handle direct "Nfps" formats which `currentUnit -q -time` might return
        default:
            if (endsWith(tolower($timeUnitSetting), "fps")) { // tolower for case-insensitivity
                string $tempFpsStr = $timeUnitSetting;
                $tempFpsStr = substitute("fps", tolower($tempFpsStr), ""); // remove "fps" (case-insensitive)
                $tempFpsStr = substitute("FPS", $tempFpsStr, "");          // remove "FPS" (uppercase)
                
                float $parsedFps = catchQuiet((float)$tempFpsStr); // Use catchQuiet to avoid error if not a number
                if ($parsedFps > 0) {
                    $fps = $parsedFps;
                } else {
                    warning ("Could not parse FPS from time unit string: '" + $timeUnitSetting + "'. Assuming 24 FPS.");
                    $fps = 24.0;
                }
            } else {
                warning ("Unrecognized time unit: '" + $timeUnitSetting + "'. Assuming 24 FPS.");
                $fps = 24.0;
            }
            break;
    }
    print ("Using FPS: " + $fps + " (derived from time unit: '" + $timeUnitSetting + "')\n");
    // -- End FPS Detection --


    // --- Read timestamps and set keyframes --- (This section remains the same)
    string $nextLine;
    print ("Setting initial base value...\n");
    // ... (rest of the keyframing logic remains identical to the previous version) ...
    while (!feof($fileID)) {
        $nextLine = fgetline($fileID);
        $nextLine = trim($nextLine); 

        if (size($nextLine) > 0) {
            float $beatTimeInSeconds = (float)$nextLine;
            float $beatFrame = $beatTimeInSeconds * $fps;

            if ($beatFrame < 0) {
                print ("Skipping beat time " + $beatTimeInSeconds + "s as it results in a negative frame ("+ $beatFrame +").\n");
                continue;
            }

            float $preBeatFrame = $beatFrame - $attackPreFrames;
            float $timelineMinFrame = `playbackOptions -q -minTime`; // Get min timeline frame

            if ($preBeatFrame < $timelineMinFrame && $attackPreFrames > 0) {
                $preBeatFrame = $timelineMinFrame; 
            }

            if ($attackPreFrames >= 0) {
                 if ($attackPreFrames > 0 || $beatFrame == $timelineMinFrame ) { // Ensure logic for first frame
                     if ($preBeatFrame < $beatFrame || ($preBeatFrame == $beatFrame && $preBeatFrame == $timelineMinFrame) ) { 
                        setKeyframe -time $preBeatFrame -value $baseValue $mashNodeAndAttribute;
                     }
                }
            }
            
            setKeyframe -time $beatFrame -value $peakValue $mashNodeAndAttribute;
            print ("Set key: " + $mashNodeAndAttribute + " = " + $peakValue + " at frame " + $beatFrame + " (time " + $beatTimeInSeconds + "s)\n");

            float $postBeatFrame = $beatFrame + $decayPostFrames;
            setKeyframe -time $postBeatFrame -value $baseValue $mashNodeAndAttribute;
            print ("Set key: " + $mashNodeAndAttribute + " = " + $baseValue + " at frame " + $postBeatFrame + "\n");
        }
    }

    fclose($fileID);
    print "Finished processing beat file and setting keyframes.\n";
    
    // Optional: Set tangent types
    // keyTangent -inTangentType clamped -outTangentType clamped $mashNodeAndAttribute;
}

// --- GUI Procedures (These remain UNCHANGED from the previous corrected version) ---
// global proc createMashBeatDriverUI() { ... }
// global proc loadSelectedMashAttributeFromUI() { ... }
// global proc browseForBeatFileFromUI() { ... }
// global proc callDriveMASHFromUI() { ... }
//
// To run the UI (after sourcing the script):
// createMashBeatDriverUI();